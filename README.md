# JPA
- 객체를 테이블에 맞추어서 모델링하면 협력관계를 만들 수 없고 다시 다 조회를 해야한다.
```java
Member m = em.find(Member.class, 1);
Team t = em.find(Team.class, m.getTeamId());
```

## 연관관계
- 다대일 관계에서 1의 pk는 다의 fk가 된다. 다가 연관관계의 주인이 된다.


## 양방향 연관관계와 연관관계의 주인
- db테이블에는 무조건 양방향임
- 객체지향에서는 단방향 , 양방향이 가능함.
- 다대일 관계에서 일의 엔티티에 @OneToMany(mappedBy = "다의 매핑된 변수명")
    - 객체와 연관관계의 차이 - 양방향으로 참조하려면 단방향을 두개 만들어야한다.
        - 객체  1. 멤버 -> 팀 2. 팀 -> 멤버 (단방향이 두개일뿐)
        - 테이블 멤버 <-> 팀
    - **둘 중 하나로 외래 키를 관리해야 한다!!!!!!!**
        - 연관 관계의 주인
        - 양방향 매핑 규칙!
        - 연관관계의 주인만이 외래키 관리
        - 주인이 아닌쪽은 `읽기만` 사용
        - 주인은 joinColumn
        - 주인이 아니면 mappedBy로 주인을 지정한다.
        - 반대편은 조회만 가능하다!!!
        - **주인은 테이블에 외래키가 있는 곳으로 정한다**
        - 그렇지 않으면 수정할 때 다른쪽 테이블에 수정 쿼리가 나간다.
- 다대일 관계에서 다의 엔티티에 @ManyToOne @JoinColumn(name = "일의pk")

## 단방향 관계만 정리하면 기본적인 매핑은 완료
- 혹시 필요하다면 양방향을 고려하는 것
- **연관관계의 주인 쪽에 데이터를 저장해줘야 디비에 정확하게 값이 들어간다**
- 주인이 아닌 곳에 저장해봐야 디비에 값이 저장되지 않는다!
- changeTeam() 등의 편의성 메소드 사용을 권장한다.
- toString, Lombok, Json 라이브러리에서 무한루프에 빠질 가능성이 있다.
- **실무에서는 절대 컨트롤러단에서 entity를 반환하지 않는다.**

## 단방향 양방향
- 테이블
    - 외래 키 하나로 조인가능
    - 사실 방향 x
- 객체
    - 참조형 필드가 있어야 참조가능
    - 단방향이 두개가 있을뿐
## 다중성
1. 다대일 @ManyToOne -> 권장
    - 테이블의 외래키가 있는 곳이 연관관계의 주인이 된다.
    - 다대일은 mappedby 가 없고 주인이 되어야 한다.
2. 일대다 @OneToMany 권장 x
    - 일의 연관관계의 주인
    - 외래키관리를 One에서 하면 쿼리가 나갈때 다의 테이블은 건드려서 별로다. 업데이트 쿼리가 더 나감
    - 실무에서 테이블이 너무 많기 때문에 확인하기가 너무 힘듬
    - joinColumn이 없으면 조인테이블이 생성됨
3. 일대일 @OneToOne
    - 외래키를 어디에 넣어도 상관없음
    - 외래키에 데이터베이스 유니크 제약조건이 추가되어야함
    - 반대편은 mapped by
4. 다대다 @ManyToMany -> 실무에서 사용 x
    - 연결 테이블을 추가해서 일대다 , 다대일 관계로 풀어내야함
    - 객체는 다대다 관계가 가능함
    - 연결 테이블을 @Entity로 승격
    - member -< memberProduct >- product 관계로 풀어내야함
    - 실무에서는 그냥 테이블에 왠만하면 generate value로 id 값을 잡아주는거 권장

## 고급매핑 - 상속관계 매핑
- 관계형 데이터베이스는 상속 관계가 없다.
- 객체의 상속관계 구조와 db 슈퍼타입 서브타입 관계를 매핑한다.
- 논리모델 to 물리 모델 전략
    - 조인 전략 : 슈퍼타입에 기본정보 insert는 두번 select는 조인
        - 비즈니스적으로 중요하고 확장가능성이 많으면 좋음
        - 정규화
        - 외래키 참조 무결성 제약조건 활용가능 다른 테이블에서도 볼 수 있음
        - 저장공간 효율성 높다
        - 단점 : 조회시 조인 사용
        - insert시 쿼리가 2번 나감
    - 단일 테이블전략 : 논리모델을 그냥 한 테이블로 합쳐버림
        - Dtype 필수
        - 성능상 이점이 있음, 단순함
        - 조회 성능이 빠름, 조회 쿼리가 단순함
        - 자식 클래스의 null허용이 필요함
        - 테이블이 커지면 조회 성능이 느려질 수도 있다.
        - 단순할 경우 단일테이블도 좋음
    - 각각 테이블에 다 가지고 있는 전략
        - 쓰면 안됨
        - 쿼리가 너무 복잡함 조회 성능이 느림
- jpa 기본 전략은 단일 테이블전략 하지만 조인 전략이 정석적
- 어떤 전략이더라도 DTYPE은 만들자.



- 오후 집에서한거
- 먼저 프록시로 가져오면 그 뒤에 find를 하더라도 프록시로 반환함
- 영속성 컨텍스트에 도움을 받을 수 없는 준영속 상태일때 레퍼런스는 예외를 터트림
- 실무에서 트랜잭션 종료후에 레퍼런스 조회하면 무조건 터짐
```java
Member refMember = em.getReference(~);
//준영속 상태로 변경햇을때
em.close(); or em.detach(refMember);
refMember.getName();
//LazyInitializationException 을 발생시킴
```
- proxy 초기화 여부  emf.gerPersistenceUnitUtil().isLoaded()
- 프록시 강제 초기화 : org.hibernate.Hibernate.initialize(entity);
- jpa표준에는 초기화기능이 없음.

## 지연로딩
- 비즈니스 로직에 따라 같이 조회할지 따로 조회할지 알아본 뒤 지연로딩과 즉시로딩을 정해야함 ( em.find )
- 지연로딩 : Lazy   즉시로딩 : Eager
- 지연로딩 시 가져온 것은 프록시 객체
- 즉시로딩은 진짜 객체로 반환해줌
## 실무 사용
- 실무에서는 지연로딩만 사용
- 즉시로딩시 전혀 예상하지 못한 쿼리가 나감(join 테이블이 너무 많아짐)
- jpql에서 N+1 의 문제가 생김
    - sql에서 가져온 뒤에 eager된 테이블을 또 조회함.
    - member - team 관계에서 team이 n개면 n개의 팀 조회 쿼리가 나감
- 기본적으로 Lazy로 세팅
    1. jpal에서 fetchjoin을 통해 동적으로 다 가져옴
    2. batch size
    3. 엔티티 그래프
- @ManyToOne , @OneToOne  -> default EAGER
- @OneToMany -> default LAZY

## 영속성 전이
- 특정 엔티티를 영속상태로 만들 때 연관된 엔티티도 함께 영속
- 부모 엔티티 저장할 때 자식 엔티티도 함께 저장
- 영속성 전이와 연관관게 매핑과는 관련 없음
- 하나의 부모가 자식들을 관리할때만 사용할때, Life Cycle이 거의 유사할때 ex) 게시판 - 첨부파일

## 고아 객체
- orphanRemoval 부모 객체에서 연관관계가 끊어지면 삭제한다
- 영속성 전이가 가능한 곳에서만 사용하기
- cascade.all + orphanRemovel=true -> 부모가 자식의 생명주기를 관리함

## 값타입
- 엔티티 타입
    - @Entity로 정의하는 객체
    - 엔티티의 값이 변해도 식별자로 인식가능
- 값 타입
    - int, Integer , String 처럼 단순히 값으로 사용
    - 식별자가 없고 값만 있음
### 기본값 타입
    - 자바 기본 타입(int, double) primitive type 은 공유 안됨 call by value
    - 래퍼 클래스 (Integer, Long) 레퍼런스이지만 공유 불가~
    - 생명주기가 엔티티에 의존 -> 회원 삭제시 이름 나이 필드도 삭제
    - 값 타입은 공유하면 안됨. side effect
### 임베디드 타입 -> 결국 엔티티의 값일뿐이다.
    - 복합 값 타입(좌표)
    - 새로운 값 타입을 직접 정의가능
    - 기본 값 타입을 모아서 만들어서 복합 값 타입
    - 엔티티와 매핑하는 테이블은 같다!!
    - @Embeddable 값 타입을 정의하는 곳(address)
    - @Embedded 값 타임을 사용하는 곳 (member)
    - 객체와 테이블을 더욱더 세밀하게 매핑이 가능하다.
    - 중복된 임베디드 타입은 @AttributeOverrides(value = AttributeOverride)를 통해 디비타입을 따로 매핑한다.
### 값타입과 불변객체
    - 임베디드 타입같은 값 타입을 여러 엔티티에서 공유하면 위험함 ( 메모리 주소를 가지고 있기 때문에)
    - 값 타입의 인스턴스를 공유하면 위험 -> 복사해서 사용해야함.
    - 객체 타입은 참조 문제를 해결할 수 없음
        - 객체 타입을 수정할 수 없게 만들면 부작용 원천 차단
        - 생성자로만 값을 설정할 수 있게 ( setter 를 private이거나 삭제)
        - 불변 객체로 만든다.
        - 수정할때 다시 생성자를 통해 만들어서 바꾼다.
### 값 타입의 비교
    - 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함.
    1. 동일성 비교
        - 인스턴스의 참조 값을 비교 == 사용
    2. 동등성 비교
        - 인스턴스의 값 비교 .equals()
        - 모든 필드를 다 비교해야한다.
        - Equals 오버라이드 할때는 왠만하면 인텔리제이가 해주는거로 해라
### 컬렉션 값 타입
    - list
    - @ElementCollection , @CollectionTable(name = "tablename", joinColumns = @JoinColumn(name = "joinColumn"))
    - 컬렉션은 한 테이블에 넣을 수 는 없다 ( 다대일 구조로 풀어내야한다)
    - 컬렉션 값 타입은 생명주기가 부모에 소속된다. cascade.all + orphanRemovel = true 처럼 동작한다.
    - 컬렉션을 찾아올때는 기본적으로 지연로딩이다.
    - 엔티티와 다르게 식별자 개념이 없기 때문에 값을 변경하면 추적이 어렵다.
    - 값 타입 컬렉션에 변경이 발생하면 -> 주인 엔티티와 관련된 모든 데이터 삭제 후 현재값을 모두 저장한다.
    - **복잡한 방법이 많기 때문에 실무에서는 컬렉션으로 들어갈 친구는 entity로 승격한다.**
    - 위의 경우에 @OneToMany(cascade = ALL, orphanRemoval = true) 로 선언한다.
    - 값타입을 사용할때는 아주 단순할때 List<String> 정도로 풀 수 있을때.